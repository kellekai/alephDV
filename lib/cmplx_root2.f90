module cmplx_alpha2

real*8 dummy(3)

contains

	SUBROUTINE set_dummy(s,atau,angle)
	
		real*8 :: s,atau,angle
		
		dummy(1) = s
		dummy(2) = atau
		dummy(3) = angle
		
	END SUBROUTINE set_dummy

SUBROUTINE ROOTS(KNOWN,NMORE,KM,REALRT,EP1,EP2,GUESS,MAXITS,RTS,NFOUND, FNV, IFAIL)

COMPLEX*16 RTS(KM), FNV(KM), X1, X2, X3, F1, F2, F3, &
X21, X32, F21, F32, F31, F321, B, XNEW, FNEW, DENOM, &
FSAVE, CSQRT, RADICL, RT, DIF, CSTEP, FSLAST
REAL*8 EP1, EP2, ONE, HUNDRD, TWO, FOUR, HALF, STEP, &
ZERO, EP1DEF, EP2DEF
INTEGER GUESS
LOGICAL REALRT
DATA IZERO,IONE,ITWO,ITHREE,ZERO,HALF,ONE,TWO,FOUR,HUNDRD,ITSDEF,EP1DEF,EP2DEF &
/0,1,2,3,0.0d0,0.5d0,1.0d0,2.0d0,4.0d0,100.0d0,100,0.5d-5,1.0d-6/
EP1 = AMAX1(EP1,EP1DEF)
EP2 = AMAX1(EP2,EP2DEF)
MAXITS = MIN0(MAXITS,ITSDEF)
IFAIL = IZERO
NFOUND = IZERO
IF (KNOWN.LT.IONE) GO TO 30
DO 10 I=1,KNOWN
II = I
CALL CALCF(RTS(I), FNV(I))
IF (ABS(FNV(II)).GE.EP2) GO TO 20
10 CONTINUE
20 IFAIL =IONE
GUESS = GUESS + KNOWN - II +IONE
NMORE = NMORE + KNOWN - II +IONE
KNOWN = II - IONE
30 CONTINUE
LOOP1 = KNOWN +IONE
LOOP2 = KNOWN + NMORE
IF (LOOP1.GT.LOOP2 .OR. LOOP1.LT.IONE) GO TO 180
IF (GUESS-NMORE) 40, 70, 60
40 ILO = GUESS + IONE
DO 50 I=ILO,LOOP2
RTS(I) = ZERO
50 CONTINUE
GO TO 70
60 CONTINUE
GUESS = NMORE
70 CONTINUE
STEP = HALF
DO 160 NEW=LOOP1,LOOP2
KOUNT = ITHREE
NEWM1 = NEW - IONE
RT = RTS(NEW)
X1 = RT - STEP
X2 = RT + STEP
X3 = RT
CALL CALCF(X1, F1)
CALL CALCF(X2, F2)
CALL CALCF(X3, F3)
FSLAST = F3
IF (NEW.GT.IONE) CALL TEST(X1, F1, FSAVE, RTS,NEWM1, EP2, KOUNT)
IF (NEW.GT.IONE) CALL TEST(X2, F2, FSAVE, RTS,NEWM1, EP2, KOUNT)
IF (NEW.GT.IONE) CALL TEST(X3, F3, FSLAST, RTS,NEWM1, EP2, KOUNT)
F21 = (F2-F1)/(X2-X1)
80 X32 = X3 - X2
F32 = (F3-F2)/X32
F321 = (F32-F21)/(X3-X1)
B = F32 + X32*F321
RADICL = B**ITWO - FOUR*F321*F3
IF (REALRT .AND. REAL(RADICL).LT.ZERO) RADICL = ZERO
RADICL = SQRT(RADICL)
IF (REAL(B)*REAL(RADICL)+AIMAG(B)*AIMAG(RADICL).LT.ZERO) RADICL = -RADICL
DENOM = B + RADICL
IF (ABS(DENOM).NE.ZERO) GO TO 100
IF (ABS(F3).GE.EP2) GO TO 90
XNEW = X3
GO TO 120
90 XNEW = X3 + X32
GO TO 120
100 CSTEP = TWO*F3/DENOM
IF (.NOT.REALRT .OR. ABS(F3).EQ.ZERO .OR. ABS(F32).EQ.ZERO) GO TO 110
CSTEP = F32/ABS(F32)*F3/ABS(F3)*ABS(CSTEP)
110 XNEW = X3 - CSTEP
120 CALL CALCF(XNEW, FNEW)
FSAVE = FNEW
IF (NEW.LE.IONE) GO TO 130
CALL TEST(XNEW, FNEW, FSAVE, RTS, NEWM1, EP2,KOUNT)
130 KOUNT = KOUNT +IONE
IF (KOUNT.GT.MAXITS) GO TO 170
DIF = XNEW - X3
IF (ABS(DIF).LT.EP1*ABS(XNEW)) GO TO 150
IF (ABS(FSAVE).LT.EP2) GO TO 150
IF (REALRT .OR. ABS(FSAVE).LT.HUNDRD*ABS(FSLAST)) GO TO 140
CSTEP = CSTEP*HALF
XNEW = XNEM + CSTEP
GO TO 120
140 X1 = X2
X2 = X3
X3 = XNEW
F1 = F2
F2 = F3
F3 = FNEW
FSLAST = FSAVE
F21 = F32
GO TO 80
150 CONTINUE
RTS(NEW) = XNEW
FNV(NEW) = FSAVE
NFOUND = NEW
160 CONTINUE
GO TO 190
170 CONTINUE
RTS(NEW) = XNEW
FNV(NEW) = FSAVE
IFAIL = ITHREE
GO TO 190
180 CONTINUE
IFAIL = ITWO
190 CONTINUE
RETURN
END

SUBROUTINE ROOTS2(KNOWN,NMORE,KM,REALRT,EP1,EP2,GUESS,MAXITS,RTS,NFOUND, FNV, IFAIL)

COMPLEX*16 RTS(KM), FNV(KM), X1, X2, X3, F1, F2, F3, &
X21, X32, F21, F32, F31, F321, B, XNEW, FNEW, DENOM, &
FSAVE, CSQRT, RADICL, RT, DIF, CSTEP, FSLAST
REAL*8 EP1, EP2, ONE, HUNDRD, TWO, FOUR, HALF, STEP, &
ZERO, EP1DEF, EP2DEF
INTEGER GUESS
LOGICAL REALRT
DATA IZERO,IONE,ITWO,ITHREE,ZERO,HALF,ONE,TWO,FOUR,HUNDRD,ITSDEF,EP1DEF,EP2DEF &
/0,1,2,3,0.0d0,0.5d0,1.0d0,2.0d0,4.0d0,100.0d0,100,0.5d-5,1.0d-6/
EP1 = AMAX1(EP1,EP1DEF)
EP2 = AMAX1(EP2,EP2DEF)
MAXITS = MIN0(MAXITS,ITSDEF)
IFAIL = IZERO
NFOUND = IZERO
IF (KNOWN.LT.IONE) GO TO 30
DO 10 I=1,KNOWN
II = I
CALL calcf2(RTS(I), FNV(I))
IF (ABS(FNV(II)).GE.EP2) GO TO 20
10 CONTINUE
20 IFAIL =IONE
GUESS = GUESS + KNOWN - II +IONE
NMORE = NMORE + KNOWN - II +IONE
KNOWN = II - IONE
30 CONTINUE
LOOP1 = KNOWN +IONE
LOOP2 = KNOWN + NMORE
IF (LOOP1.GT.LOOP2 .OR. LOOP1.LT.IONE) GO TO 180
IF (GUESS-NMORE) 40, 70, 60
40 ILO = GUESS + IONE
DO 50 I=ILO,LOOP2
RTS(I) = ZERO
50 CONTINUE
GO TO 70
60 CONTINUE
GUESS = NMORE
70 CONTINUE
STEP = HALF
DO 160 NEW=LOOP1,LOOP2
KOUNT = ITHREE
NEWM1 = NEW - IONE
RT = RTS(NEW)
X1 = RT - STEP
X2 = RT + STEP
X3 = RT
CALL calcf2(X1, F1)
CALL calcf2(X2, F2)
CALL calcf2(X3, F3)
FSLAST = F3
IF (NEW.GT.IONE) CALL test2(X1, F1, FSAVE, RTS,NEWM1, EP2, KOUNT)
IF (NEW.GT.IONE) CALL test2(X2, F2, FSAVE, RTS,NEWM1, EP2, KOUNT)
IF (NEW.GT.IONE) CALL test2(X3, F3, FSLAST, RTS,NEWM1, EP2, KOUNT)
F21 = (F2-F1)/(X2-X1)
80 X32 = X3 - X2
F32 = (F3-F2)/X32
F321 = (F32-F21)/(X3-X1)
B = F32 + X32*F321
RADICL = B**ITWO - FOUR*F321*F3
IF (REALRT .AND. REAL(RADICL).LT.ZERO) RADICL = ZERO
RADICL = SQRT(RADICL)
IF (REAL(B)*REAL(RADICL)+AIMAG(B)*AIMAG(RADICL).LT.ZERO) RADICL = -RADICL
DENOM = B + RADICL
IF (ABS(DENOM).NE.ZERO) GO TO 100
IF (ABS(F3).GE.EP2) GO TO 90
XNEW = X3
GO TO 120
90 XNEW = X3 + X32
GO TO 120
100 CSTEP = TWO*F3/DENOM
IF (.NOT.REALRT .OR. ABS(F3).EQ.ZERO .OR. ABS(F32).EQ.ZERO) GO TO 110
CSTEP = F32/ABS(F32)*F3/ABS(F3)*ABS(CSTEP)
110 XNEW = X3 - CSTEP
120 CALL calcf2(XNEW, FNEW)
FSAVE = FNEW
IF (NEW.LE.IONE) GO TO 130
CALL test2(XNEW, FNEW, FSAVE, RTS, NEWM1, EP2,KOUNT)
130 KOUNT = KOUNT +IONE
IF (KOUNT.GT.MAXITS) GO TO 170
DIF = XNEW - X3
IF (ABS(DIF).LT.EP1*ABS(XNEW)) GO TO 150
IF (ABS(FSAVE).LT.EP2) GO TO 150
IF (REALRT .OR. ABS(FSAVE).LT.HUNDRD*ABS(FSLAST)) GO TO 140
CSTEP = CSTEP*HALF
XNEW = XNEM + CSTEP
GO TO 120
140 X1 = X2
X2 = X3
X3 = XNEW
F1 = F2
F2 = F3
F3 = FNEW
FSLAST = FSAVE
F21 = F32
GO TO 80
150 CONTINUE
RTS(NEW) = XNEW
FNV(NEW) = FSAVE
NFOUND = NEW
160 CONTINUE
GO TO 190
170 CONTINUE
RTS(NEW) = XNEW
FNV(NEW) = FSAVE
IFAIL = ITHREE
GO TO 190
180 CONTINUE
IFAIL = ITWO
190 CONTINUE
RETURN
END


SUBROUTINE TEST2(X, F, FSAVE, RTS, K, EPS, KOUNT)
COMPLEX*16 X, F, RTS(K), D, FSAVE
REAL*8 EPS!, CABS
DATA IONE, PERTB /1,0.01d0/
10 CONTINUE
DO 20 I=1,K
D = X - RTS(I)
IF (ABS(D).LE.EPS) GO TO 30
F = F/D
20 CONTINUE
GO TO 40
30 CONTINUE
X = X + PERTB
CALL calcf2(X, F)
FSAVE = F
KOUNT = KOUNT +IONE
GO TO 10
40 RETURN
END

SUBROUTINE TEST(X, F, FSAVE, RTS, K, EPS, KOUNT)
COMPLEX*16 X, F, RTS(K), D, FSAVE
REAL*8 EPS!, CABS
DATA IONE, PERTB /1,0.01d0/
10 CONTINUE
DO 20 I=1,K
D = X - RTS(I)
IF (ABS(D).LE.EPS) GO TO 30
F = F/D
20 CONTINUE
GO TO 40
30 CONTINUE
X = X + PERTB
CALL calcf(X, F)
FSAVE = F
KOUNT = KOUNT +IONE
GO TO 10
40 RETURN
END

Subroutine calcf(x,f) 

  real*8 s,angle
  real*8  :: pi = 4.0d0 * atan(1.0d0)
  real*8  :: mtau = 1.77684d0
  complex*16 C8_Hatau,C8_Has,as,atau,beta,f,x

  as = x
  angle = dummy(3)
  s = dummy(1)
  atau = dcmplx(dummy(2),0.0d0)
  
  C8_Has = -0.2222222222222222d0/(as/pi) + 0.3730002895803152d0 * atan(0.1957622473346858d0 - 2.777520917064214d0*(as/pi)) - & 
		0.3950617283950617d0 * log((as/pi)) + 0.2727626771780712d0 * log(0.3539687005190283d0 + 1.0d0 * (as/pi)) + &
		0.06114952560849528d0 * log(0.13459153249825306d0 - 0.14096185280332845d0 * (as/pi) + 1.0d0 * (as/pi)**2)
  
  C8_Hatau = -0.2222222222222222d0/(atau/pi) + 0.3730002895803152d0 * atan(0.1957622473346858d0 - 2.777520917064214d0*(atau/pi)) - & 
		0.3950617283950617d0 * log((atau/pi)) + 0.2727626771780712d0 * log(0.3539687005190283d0 + 1.0d0 * (atau/pi)) + &
		0.06114952560849528d0 * log(0.13459153249825306d0 - 0.14096185280332845d0 * (atau/pi) + 1.0d0 * (atau/pi)**2)
		
  beta = log(s*exp(dcmplx(0.0d0,angle-pi))/mtau**2)/2.0d0
  
  f = C8_Has - C8_Hatau + beta
  
  return
end

Subroutine calcf2(x,f) 

  real*8 s,angle
  real*8  :: pi = 4.0d0 * atan(1.0d0)
  real*8  :: mtau = 1.77684d0
  complex*16 C8_Hatau,C8_Has,as,atau,beta,f,x

  as = x
  angle = dummy(3)
  s = dummy(1)
  atau = dcmplx(dummy(2),0.0d0)
  
  C8_Has = -0.2222222222222222d0/(as/pi) + 0.3730002895803152d0 * atan(0.1957622473346858d0 - 2.777520917064214d0*(as/pi)) - & 
		0.3950617283950617d0 * log((as/pi)) + 0.2727626771780712d0 * log(0.3539687005190283d0 + 1.0d0 * (as/pi)) + &
		0.06114952560849528d0 * log(0.13459153249825306d0 - 0.14096185280332845d0 * (as/pi) + 1.0d0 * (as/pi)**2)
  
  C8_Hatau = -0.2222222222222222d0/(atau/pi) + 0.3730002895803152d0 * atan(0.1957622473346858d0 - 2.777520917064214d0*(atau/pi)) - & 
		0.3950617283950617d0 * log((atau/pi)) + 0.2727626771780712d0 * log(0.3539687005190283d0 + 1.0d0 * (atau/pi)) + &
		0.06114952560849528d0 * log(0.13459153249825306d0 - 0.14096185280332845d0 * (atau/pi) + 1.0d0 * (atau/pi)**2)
		
  beta = log(s*exp(dcmplx(0.0d0,angle))/mtau**2)/2.0d0
  
  f = C8_Has - C8_Hatau + beta
  
  return
end

end module
